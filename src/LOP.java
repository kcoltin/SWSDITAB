//******************************************************************************
// LOP.java
// Kevin Coltin  
//
// Represents a single linear optimization problem. The problem must be in max
// form and all constraints must be equality, not inequalities. It is intended
// to be used as part of a larger integer LOP. It is designed specifically for
// LOPs resulting from the pairing algorithm and thus is not generally 
// applicable. The LOP is assumed to have a certain number of equality 
// constraints, followed by possibly one or more inequality constraints (which 
// are all strictly below the equality constraints). 
//******************************************************************************




public class LOP implements Solution
{
	private int[][] tableau; 
	
	//Number of problem variables, slack variables, and constraints 
	private final int nvars, nconsts, nslacks; 
	private final int nrows, ncols; //number of rows and columns 
	
	private static final double EPSILON = .0001; //for floating pt comparisons
	
	//value of previous pivot, used by pivot() method. This is equivalent to the
	//coefficient of each basic variable. 
	private int prevPivotVal; 
	
	//codes used by addConstraint method 
	private static final int LESS_THAN = 1, GREATER_THAN = 2; 
	

	//---------------------------------------------------------------------------
	// Constructor - takes as its argument a two-dimensional array that is the
	// problem tableau, and the number of *problem* (as opposed to slack) 
	// variables. 
	//---------------------------------------------------------------------------
	public LOP (int[][] table, int nvar)
	{
		tableau = table;
		nvars = nvar;
		nconsts = table.length - 1; 
		nrows = table.length; 
		ncols = table[0].length; 
		nslacks = ncols - nvars - 2; 
		
		prevPivotVal = 1; 
		
		//Convert tableau to final solved form 
		solveSimplex(); 
	}
	
	
	//---------------------------------------------------------------------------
	// Indicates whether this LOP has a feasible solution (not necessarily an 
	// integral one). 
	//---------------------------------------------------------------------------
	public boolean isFeasible ()
	{
		for (int i = 0; i < nconsts; i++)
		{
			if (tableau[i][ncols-1] < 0)
				return false;
		}

		return true;
	}


	//---------------------------------------------------------------------------
	// Indicates whether this branch of the ILOP is complete - whether the true 
	// objective value has been obtained and this branch is done being "solved".
	// This is equivalent to it having an integer solution or being infeasible. 
	// (Recall that the LOP is solved as soon as it is constructed so it is 
	// always "completed" in the sense of being solved; the question is just
	// whether we need to keep digging to find an integral solution.) 
	//---------------------------------------------------------------------------
	public boolean isComplete ()
	{
		return isFeasible() == false || isIntegral();
	}
	
	
	//---------------------------------------------------------------------------
	// Returns the objective value (the z* value) for this particular problem
	// instance. (This will only be called after calling isComplete and 
	// isFeasible to make sure there actually is an objective.) 
	//---------------------------------------------------------------------------
	public double getObjective ()
	{
		return (double) tableau[nrows-1][ncols-1] / tableau[nrows-1][ncols-2]; 
	}
	
	
	//---------------------------------------------------------------------------
	// Returns a value that is an upper bound, if it exists, on not only this 
	// problem instance but also on all of the solutions that can be derived from
	// it. This is the same as the floor of the objective value, because the
	// objective value of all subproblems is bounded by the objective of this
	// parent problem. If it is infeasible, it provides no bound. 
	//---------------------------------------------------------------------------
	public int getBound ()
	{
		if (isFeasible())
			return (int) Math.floor(getObjective());
		else
			return Integer.MIN_VALUE; 
	}



	//---------------------------------------------------------------------------
	// Returns tableau 
	//---------------------------------------------------------------------------
	public int[][] getTableau ()
	{
		return tableau; 
	}

	//---------------------------------------------------------------------------
	// Performs the Simplex algorithm to solve this FLOP. (This is specific to 
	// form of the LOPs generated by the pairing algorithm - all variables are 
	// nonnegative and all constraints are equality, and the problem is neither
	// infeasible nor unbounded.) 
	//---------------------------------------------------------------------------
	private void solveSimplex ()
	{
		doPhaseZero ();
		doPhaseI (); 
		
		if (isFeasible())
			doPhaseII (); 
	}


	//---------------------------------------------------------------------------
	// Indicates whether the solution (meaning the problem variables) is all 
	// integral. 
	//---------------------------------------------------------------------------
	private boolean isIntegral ()
	{
		for (int j = 0; j < nvars; j++)
		{
			double x = getValueOfVariable(j);
			if (Math.abs(x % 1) > EPSILON) //if x is nonintegral 
				return false;
		}
		
		return true; 
	}



	//---------------------------------------------------------------------------
	// Does Phase 0, pivoting on variables in least subscript order to form a 
	// basis. 
	//---------------------------------------------------------------------------
	private void doPhaseZero ()
	{
		//Cycle through each row 
		for (int i = 0; i < nconsts; i++)
		{
			//Get farthest-left non-zero entry in row i 
			int j = 0; 
			while (j < nvars + nslacks && tableau[i][j] == 0)
				j++; 
			
			//if it goes past the last column, this row is all zeros
			if (j == nvars + nslacks)
				continue; 
			
			//Otherwise, pivot on this entry. 
			pivot(i, j);			
		}
	}




	//---------------------------------------------------------------------------
	// Does Phase I of the Simplex algorithm, converting it to a feasible 
	// solution 
	//---------------------------------------------------------------------------
	private void doPhaseI ()
	{
		while (isFeasible() == false)
		{
			int r = 0; 
			
			//Find the most negative value in the far right column (note: the 
			//feasibility check above guarantees at least one entry will be 
			//negative)
			for (int i = 0; i < nconsts; i++)
			{
				if (tableau[i][ncols-1] < tableau[r][ncols-1])
					r = i; 
			}
			
			//Find column to pivot on (the negative entry with least subscript) 
			int c = -1; 
			
			for (int j = 0; j < nvars + nslacks; j++)
			{
				if (tableau[r][j] < 0)
				{
					c = j; 
					break;
				}
			}
			
			//If there is no negative pivot, the problem is infeasible 
			if (c == -1)
				return; 
			
			//Pivot on selected row/columns 
			pivot (r, c);
		}
	}


	//---------------------------------------------------------------------------
	// Peforms Phase II of the Simplex algorithm (when the basis is feasible) 
	//---------------------------------------------------------------------------
	private void doPhaseII ()
	{
		while (true) //repeat
		{
			//Find pivot column- the negative entry on the bottom row with the
			//least subscript
			int c = -1;

			for (int j = 0; j < nvars + nslacks; j++)
			{
				if (tableau[nrows-1][j] < 0)
				{
					c = j;
					break;
				}
			}

			//If there are no negative entries in the objective row, the optimal
			//solution has been found.
			if (c == -1)
				return;

			//Find pivot row- the row with the lowest nonnegative ratio b/a, where
			//b is the rightmost entry and a is the entry in column c. (Notes: a
			//must be positive, even if the ratio = 0. Checking this first also
			//avoids a divide by zero exception.)
			int r = -1;
		
			for (int i = 0; i < nconsts; i++)
			{
				int a = tableau[i][c]; 
				int b = tableau[i][ncols-1]; 
			
				if (r >= 0)
				{
					//Check whether row i has a lower nonnegative ratio
					if (a > 0 && b/a >= 0 
						&& (double) b/a < (double) tableau[r][ncols-1]/tableau[r][c])
					{
						r = i;
					}

					//Check whether there is a tie- if so, pivot on the row such
					//that the leaving variable has the least subscript.
					else if (a > 0 && b/a >= 0 && Math.abs((double) b/a 
						- (double) tableau[r][ncols-1]/tableau[r][c]) < EPSILON)
					{
						//Iterate through columns until you find the column where the
						//entry in either row i or row r is the only nonzero entry - 
						//whichever one it encounters first is the pivot row as per 
						//the least subscripts criterion 
						for (int j = 0; j < nvars + nslacks; j++)
						{
							//Check if (i,j) is the only nonzero entry in its column
							if (isBasicVariable(i, j))
							{
								r = i; //set i as new pivot row 
								break;
							}
							if (isBasicVariable(r, j))
							{
								break; //r remains the pivot row
							}
						}
					}
				}
				else 
				{
					if (a > 0 && b/a >= 0)
						r = i; 
				}
			}
			
			//If there is no pivot with a nonnegative b/a ratio, the problem is 
			//unbounded. This should not happen, because the maximum possible value
			//of the objective value should be zero 
			if (r == -1)
			{
				System.out.println("Error: LOP is unbounded. This should not "
					+ "happen - fix this error. (In LOP.doPhaseII())");
				return;
			}
			
			//Pivot on selected row and column
			pivot (r, c);
		}
	}




	//--------------------------------------------------------------------------
	// Returns the value of the variable in a particular column (after the
	// Simplex algorithm is completed). If there is only one nonzero entry in
	// the column, the value is the value in the far right column of the row
	// containing the nonzero entry divided by the nonzero entry. If there are
	// multiple nonzero entries, the variable equals zero.
	//--------------------------------------------------------------------------
	private double getValueOfVariable (int column)
	{
		//If all goes right, x should take on a nonzero value (at least at some
		//intermediate step). It's initialized to zero just to satisfy the
		//compiler.
		double x = 0;

		//Find the first nonzero entry (moving down), and set x = b/a (where b is
		//the rightmost entry in that row)
		int i = 0;

		while(i < nconsts)
		{
			if (tableau[i][column] != 0)
			{
				x = (double) tableau[i][ncols-1] / tableau[i][column];
				i++; //need to increment i before breaking, or the next loop will
						//just check the same entry.
				break;
			}

			i++;
		}

		//Check if there are any more nonzero entries (if so, the variable for
		//this column is not part of the basis and thus equals zero)
		while (i < nconsts)
		{
			if (tableau[i][column] != 0)
			{
				x = 0;
				break;
			}

			i++;
		}

		return x;
	}



	//--------------------------------------------------------------------------
	// Determines whether there is a basic variable in the given column with its
	// coefficient in the given row. I.e., returns "true" if entry (row, column)
	// is the only nonzero entry in the given column. (Be careful- it will still
	// return true if the column is the z-column or the farthest left column,
	// even though these are not truly basic variables.)
	//--------------------------------------------------------------------------
	private boolean isBasicVariable (int row, int column)
	{
		//Check that entry (row, column) is nonzero
		if (tableau[row][column] == 0)
			return false;

		//Check that all other entries in the column (excluding objective row)
		//are nonzero
		for (int i = 0; i < nconsts; i++)
		{
			//Skip the given row
			if (i == row)
				continue;

			if (tableau[i][column] != 0)
				return false;
		}

		return true;
	}


	//---------------------------------------------------------------------------
	// Does a pivot operation on the entry in the given row and column. The row
	// is first divided by the value of the pivot entry, and then the row is
	// multiplied and added to the other rows to erase their entry in the given
	// column.
	//---------------------------------------------------------------------------
	private void pivot (int row, int column)
	{
		//If pivot is negative, multiply pivot row by -1 (this will occur in
		//Phase I)
		if (tableau[row][column] < 0)
		{
			for (int j = 0; j < ncols; j++)
				tableau[row][j] = (-1) * tableau[row][j];
		}

		//Get entering and leaving variables
		int enteringVariable = column + 1; //Add 1 to get the variable subscript
		int leavingVariable = 0; //must be initialized to satisfy compiler

		for (int j = 0; j < ncols - 1; j++)
		{
			if (isBasicVariable (row, j))
				leavingVariable = j + 1; //Add 1 to get the variable subscript
		}
		
		//temporarily hold pivot value to input at end of function (don't want to
		//overwrite prevPivotVal yet) 
		int tempPPV = tableau[row][column];
		
		//Cycle through each row- multiply row i by the value of the pivot entry
		//and the pivot row by the entry in row i of the pivot column. Then
		//subtract the pivot row from row i, and divide the pivot row to what it
		//was originally.
		for (int i = 0; i < nrows; i++)
		{
			//skip the pivot row
			if (i == row)
				continue;
			
			//Factor by which the pivot row will be multiplied before subtracting
			//it from the current row i (it's set so it will erase the entry in
			//row i and the pivot column)
			int factor = tableau[i][column];
			
			for (int j = 0; j < ncols; j++)
			{
				//Multiply by the pivot entry
				tableau[i][j] *= tableau[row][column];

				//Subtract the pivot row (multiplied by the factor)
				tableau[i][j] -= tableau[row][j] * factor;

				//Divide entry i,j by the previous pivot value. (Note that at this
				//point, the i,j entry will necessarily be divisible by this value
				//due to the algorithm. Note that size-2 returns index of the pivot
				//before the current one.
				tableau[i][j] /= prevPivotVal;
			}
		}
		
		//record pivot value 
		prevPivotVal = tempPPV; 
	}
	
	
	//---------------------------------------------------------------------------
	// Returns an enumeration containing all child problems 
	//---------------------------------------------------------------------------
	public LOPChildren getSuccessors ()
	{
		return new LOPChildren(this);		
	}


	//---------------------------------------------------------------------------
	// Called by the LOPChildren object of which this LOP is a container. It 
	// does the "branch" part of branch and bound and returns the two subproblems
	// if any. 
	//---------------------------------------------------------------------------
	LOP[] getChildren ()
	{
		//If this LOP is either infeasible or integral, there are no successors 
		if (isComplete())  
			return null; 
		
		//Find the least-subscript nonintegral problem variable. 
		int j = 0; //subscript of variable to branch on
		double x = 0; //value of variable to branch on
		
		while (j < nvars)
		{
			x = getValueOfVariable(j); 
			
			if (Math.abs(x % 1) > EPSILON) //if x is nonintegral 
				break; 
			
			j++;
		}
		
		//If j == nvars, then all variables are integral, so it should have 
		//returned iscomplet == true above. This shouldn't happen. 
		if (j == nvars)
		{
			System.out.println("Error in LOP.getChildren() - all variables are "
			 + "integral, but isComplete() returns false.");
			return null;
		}
		
		//Branch on x(j) <= a or x(j) >= b, where a and b are the floor and ceil 
		//of the current x value. 
		int a = (int) Math.floor(x); 
		int b = (int) Math.ceil(x); 
		
		//Create new tableaux after adding rows for constraints x <= a and x >= b
		int[][] tableauLT = addConstraint (j, a, LESS_THAN);
		int[][] tableauGT = addConstraint (j, b, GREATER_THAN); 
		
		//Return array of the two new child LOPs 
		LOP lopLT = new LOP (tableauLT, nvars);
		LOP lopGT = new LOP (tableauGT, nvars); 
		
		LOP[] out = {lopLT, lopGT}; 
		return out; 
	}


	//---------------------------------------------------------------------------
	// Returns a new tableau created by adding a constraint of the form 
	// x(j) <= b or of the form x(j) >= b. Type should be either LOP.LESS_THAN
	// or LOP.GREATER_THAN. 
	//---------------------------------------------------------------------------
	private int[][] addConstraint (int column, int b, int type)
	{
		//Create new tableau with blank row at bottom 
		int[][] newTab = new int[nrows+1][ncols+1]; 
		
		//Copy existing constraint rows 
		for (int i = 0; i < nconsts; i++)
		{
			for (int j = 0; j < nvars + nslacks; j++)
				newTab[i][j] = tableau[i][j]; 
			
			newTab[i][ncols] = tableau[i][ncols-1]; 
		}

		//Copy objective row into last row of new tableau 
		for (int j = 0; j < nvars + nslacks; j++)
			newTab[nrows][j] = tableau[nrows-1][j]; 
		
		//Copy objective (z) entry and entry to left of it
		newTab[nrows][ncols] = tableau[nrows-1][ncols-1]; 
		newTab[nrows][ncols-1] = tableau[nrows-1][ncols-2]; 
		
		//Add entry for variable x(j)
		newTab[nconsts][column] = 1;
		
		//Add entry for slack var 
		if (type == LESS_THAN)
			newTab[nconsts][nvars+nslacks] = 1; 
		if (type == GREATER_THAN)
			newTab[nconsts][nvars+nslacks] = -1;
		
		//Add a entry 
		newTab[nconsts][ncols] = b;
		
		//Multiply new constraint row so that its basic variable (the new slack
		//var) has the correct basic coefficient. 	
		
		//Find factor to multiply the row by (this will convert the coefficient of
		//the new slcak var to the current basic coefficent) 
		int factor = type == LESS_THAN ? prevPivotVal : -prevPivotVal; 
		
		//Multiply new row by factor 
		for (int j = 0; j < nrows + 1; j++)
			newTab[nconsts][j] *= factor;
		
		return newTab; 
	}
	
	
	//---------------------------------------------------------------------------
	// Method used for testing/debugging 
	//---------------------------------------------------------------------------
	public void print ()
	{
		for (int i = 0; i < nrows; i++)
		{
			for (int j = 0; j < ncols; j++)
				System.out.print(tableau[i][j] + "  ");
		
			System.out.print("\n");
		}
		
		System.out.println("\n\n"); 
	}
	
	public static void print(int[][] tab)
	{
		for (int i = 0; i < tab.length; i++)
		{
			for (int j = 0; j < tab[0].length; j++)
				System.out.print(tab[i][j] + "  ");
		
			System.out.print("\n");
		}
		
		System.out.println("\n\n"); 
	}


}




























